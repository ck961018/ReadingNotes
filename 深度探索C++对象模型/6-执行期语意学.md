# 六、执行期语意学
## 对象的构造和析构
析构函数被放置在区段中的每一个离开点，因此尽量将对象初始化在使用它的代码附件，以避免额外的附加代码。
#### 全局对象
* C++规定在**第一次使用**前将全局对象初始化。
* 静态初始化和内存释放操作被放在以文件名编码的函数中，供main函数调用。
#### 局部静态对象
C++标准**强制要求**局部静态变量只在被调用时进行构造。
#### 对象数组
略
## new和delete运算符
* new必须返回一个独一无二的指针。
* 当内存申请失败，new会调用_new_handler函数，这个函数可以自定义。
#### 针对数组的new语意
* 只有当对象存在默认构造函数时，才会调用vec_new函数。
* new数组时会将数组size存在“联合数组”中，然后在delete时取出需要释放的size。用户指定的delete size将会被无视（*现代编译器会直接报错*）。
* 基类指针数组无法正确获取实际指针类型的析构函数，需要用户手动进行类型转换和调用（*现代编译器好像并不支持这种操作*），因此不建议使用基类指针数组。
#### Placement Operator new的语意
* placement new 不会析构指针上的对象，需要用户主动析构。
* placement new 一般而言不支持多态。
## 临时性对象
临时性对象只有在需要时才会被创建，在表达式完整评估之后才会被销销毁。举例说明：
```cxx
class A
{
public:
    A()
    {
        cout << "A" << endl;
    }
    virtual ~A()
    {
        cout << "~A" << endl;
    }
    A operator+(const A& other)
    {
        cout << "+" << endl;
        return *this;
    }
    bool operator()()
    {
        return true;
    }
};
```
当如下调用时：
```cxx

int main()
{
    A a, b;
    if ((a + b)() || (a + b)()) 
    {
        cout << "---------" << endl;
    }
}
```
仅生成一个临时对象：
```
A
A
+
~A
--------
~A
~A
```
将或运算改为与运算：
```cxx

int main()
{
    A a, b;
    if ((a + b)() && (a + b)()) 
    {
        cout << "---------" << endl;
    }
}
```
就会产生两个临时对象：
```
A
A
+
+
~A
~A
--------
~A
~A
```
可以看到，临时对象都在表达式评估完成后被销毁。  
只有两种情况除外：
1. 临时对象所在的表达式被用来初始化对象；
2. 临时对象被一个<font color=red>**引用**</font>所绑定时。

**不要为临时变量绑定指针，即便它有时候表现得符合预期：**
```
string a, b;
const char* c = (a + b).c_str();
```
**第二句的生成的临时变量会在表达式之后被销毁，`c`所指向的地址不合法。**
