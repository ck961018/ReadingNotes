# 五、构造、析构、拷贝语意学
#### 纯虚函数的存在
* 书中提到被定义的纯虚函数可以通过类名静态调用，但现代编译器好像已经不支持了。
* 虚析构函数必须被定义，即使它被设定为纯虚函数。*（纯虚函数可以在类体外被定义，只有msvc可以在类体内定义，但也不支持类体内纯虚析构函数的定义）*
* 建议不要把虚析构函数声明为纯虚。
#### 虚拟规格的存在
合理地使用virtual关键字，避免性能的损失。
#### 虚拟规格中const的存在
不建议虚函数被声明为const。
#### 重新考虑class的声明
* 不把析构函数声明为纯虚函数；
* 不把虚函数声明为const函数；
* 不把类型无关的函数声明为虚函数；
* 为成员变量在构造函数中提供初始化操作。*（c++11开始可以用默认成员初始化器进行初始化）*
- - -
## “无继承”情况下的对象构造
当某个类满足以下条件时，它可以被识别为POD（Plain Old Data):
* Trivial constructor
* Trivial destructor
* Trivial copy constructor
* Trivial copy assignment operator

POD的内存布局与C兼容，可以用memcpy和memset等进行拷贝和初始化。
#### 抽象数据类型
略
#### 为继承做准备
略
- - -
## 继承体系下的对象构造
构造函数执行前的扩充操作：
1. 从左到右，由深至浅调用virtual base class构造函数；
2. 以声明顺序调用base class构造函数（与初始化列表中的顺序无关）；
3. 初始化vptr；
4. 调用没有出现在初始化列表中对象的默认构造函数；
5. 以声明顺序初始化初始化列表中的成员（与初始化列表中的顺序无关）。
#### 虚拟继承
* 在虚拟继承链中，只有最底层的class能调用virtual bass的构造函数。
#### vptr初始化语意学
* 为了保证构造函数中调用的成员函数为当前类的成员函数，需要将vptr的初始化放在base class调用之后及初始化列表初始化之前。*（会有效率的损失，不清楚现代编译器是否是这样实现的）*
* 在初始化列表中调用该类的虚函数是安全的，但函数本身若依赖成员变量还是会出问题，因此不建议这么做。
- - -
## 对象复制语意学
* 虚拟继承的拷贝函数无法避免virtual base class的多重拷贝，因此建议不允许virtual base class拷贝操作。
- - -
## 对象的效能
* bitwise copy的效率最高，无论单一继承还是多重继承，都不会对效率产生影响。
* 其它情况下，构造与拷贝的效率与继承体系的复杂程度负相关。单一继承、多重继承、虚拟继承效率依次降低。
## 析构语意学
只有当数据成员或父类拥有析构函数时，编译器才会自动合成析构函数。若已存在析构函数，则会被扩展。

扩展顺序如下：
1. 执行析构函数本体；
2. 以声明顺序的相反顺序调用数据成员的析构函数；
3. 若存在vptr，则重新设定以指向适当base class的vtbl；
4. 以声明顺序的相反顺序调用非虚拟继承基类的析构函数；
5. 以构造顺序的相反顺序调用虚拟继承基类的析构函数。
